// Copyright 2023 DreamWorks Animation LLC
// SPDX-License-Identifier: Apache-2.0

//
//
#pragma once

#include <iostream> // debug
#include <iomanip>
#include <sstream>

namespace scene_rdl2 {
namespace real_util {

//
// The following {float,double}ToleranceEqual() are useful for the equality judgment of
// 2 float/double values with tolerance precision control.
// Keep in mind, following functions only work with a non-zero value.
// Tolerance precision is controlled by bit-mask which is generated by compareMaskGen{32,64}().
// 
// If you generate compareMask by small bitSize number, compare tolerance is small and executes high
// precision equality judgment. On the other hand, if you generate compareMask by big bitSize number,
// compare tolerance is big and executes low precision equality judgment.
//
// example-1
//    
//   float a = 1.234;
//   float b = 1.2340001;
//
//   // exact bitImage compare
//   assert(!real_util::floatToleranceEqual(a, b, real_util::compareMaskGen32(0)));
//
//   // a and b are considered as the equal value under 1-bit tolerance
//   assert(real_util::floatToleranceEqual(a, b, real_util::compareMaskGen32(1))));
//
// example-2
//
//   float a = 12340000.0;
//   float b = 12340001.0;
//
//   // exact bitImage compare
//   assert(!real_util::floatToleranceEqual(a, b, real_util::compareMaskGen32(0)));
//
//   // a and b are considered as the equal value under 1-bit tolerance
//   assert(real_util::floatToleranceEqual(a, b, real_util::compareMaskGen32(1))));
//
// example-3
//
//   double a = 78.9;
//   double b = 78.9000000000001;
//
//   // 2-bit tolerance returns false
//   assert(!real_util::doubleToleranceEqual(a, b, real_util::compareMaskGen64(2)));
//
//   // a and b are considered as the equal value under 3-bit tolerance
//   assert(real_util::doubleToleranceEqual(a, b, real_util::compareMaskGen64(3)));
//    

inline
unsigned int
compareMaskGen32(unsigned int maskBitSize)
//
// This function generate bitmask for floatToleranceEqual()¡Çs 3rd argument
//
{
    unsigned int mask = 0x0;
    for (unsigned int i = 0; i < ((maskBitSize > 32) ? 32 : maskBitSize); ++i) {
        mask |= (0x1 << i);
    }
    return mask;
}

inline
bool
floatToleranceEqual(const float &a, const float &b, const unsigned int compareMask32)
//
// Tolerance equal compare operation for float value
// Compare the bit-wise difference of IEEE 32bit float format.
// Only works with a non-ZERO value.
// return true when 2 values are the same under defined precision. otherwise, return false.
//
{
    union {
        float f;
        unsigned int ui;
    } uniA, uniB;
    uniA.f = a; unsigned int ai = uniA.ui;
    uniB.f = b; unsigned int bi = uniB.ui;
    if (ai < bi) {
        return compareMask32 >= (bi - ai);
    } else {
        return compareMask32 >= (ai - bi);
    }
}

inline
std::string
floatDump(const float &v)
//
// for debug
//
{
    union {
        float f;
        unsigned int ui;
    } uni;

    auto showAsHex = [&](const float &v) -> std::string {
        uni.f = v;
        std::ostringstream ostr;
        ostr << std::hex << std::setfill('0') << std::setw(8) << uni.ui << std::dec;
        return ostr.str();
    };

    auto showAsBitImage = [&](const float &v) -> std::string {
        uni.f = v;
        std::ostringstream ostr;
        for (int i = 31; i >= 0; --i) {
            ostr << ((uni.ui >> i) & 0x1);
            if (i == 16) ostr << ' ';
            else if (i != 0 && i % 4 == 0) ostr << '-';
        }
        return ostr.str();
    };

    std::ostringstream ostr;
    ostr << "float dump {\n"
         << "  val:" << v << '\n'
         << "  hex:0x" << showAsHex(v) << '\n'
         << "  bit:" << showAsBitImage(v) << '\n'
         << "}";
    return ostr.str();
}

//------------------------------------------------------------------------------------------

inline
unsigned long
compareMaskGen64(unsigned int maskBitSize)
//
// This function generate bitmask for doubleToleranceEqual()¡Çs 3rd argument
//
{
    unsigned long mask = 0x0;
    for (unsigned int i = 0; i < ((maskBitSize > 64) ? 64 : maskBitSize); ++i) {
        mask |= ((unsigned long)(0x1) << i);
    }
    return mask;
}

inline
bool
doubleToleranceEqual(const double &a, const double &b, const unsigned long compareMask64)
//
// Tolerance equal compare operation for double value
// Compare the bit-wise difference of IEEE 64bit double format.
// Only works with a non-ZERO value.
// return true when 2 values are the same under defined precision. otherwise, return false.
//
{
    union {
        double d;
        unsigned long ul;
    } uniA, uniB;
    uniA.d = a; unsigned long al = uniA.ul;
    uniB.d = b; unsigned long bl = uniB.ul;
    if (al < bl) {
        return compareMask64 >= (unsigned long)(bl - al);
    } else {
        return compareMask64 >= (unsigned long)(al - bl);
    }
}

inline
std::string
doubleDump(const double &v)
//
// for debug
//
{
    union {
        double d;
        unsigned long ul;
    } uni;

    auto showAsHex = [&](const double &v) -> std::string {
        uni.d = v;
        std::ostringstream ostr;
        ostr << std::hex << std::setfill('0') << std::setw(16) << uni.ul << std::dec;
        return ostr.str();
    };

    auto showAsBitImage = [&](const double &v) -> std::string {
        uni.d = v;
        std::ostringstream ostr;
        for (int i = 63; i >= 0; --i) {
            ostr << ((unsigned long)(uni.ul >> i) & 0x1);
            if (i == 16) ostr << ' ';
            else if (i != 0 && i % 4 == 0) ostr << '-';
        }
        return ostr.str();
    };

    std::ostringstream ostr;
    ostr << "double dump {\n"
         << "  val:" << v << '\n'
         << "  hex:0x" << showAsHex(v) << '\n'
         << "  bit:" << showAsBitImage(v) << '\n'
         << "}";
    return ostr.str();
}

} // namespace real-util
} // namespace scene_rdl2

